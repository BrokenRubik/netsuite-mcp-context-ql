<style>
    .bar {
        height: 10px;
        background: #eee;
        border-radius: 8px;
        overflow: hidden
    }

    .fill {
        height: 100%;
        width: 0%;
        background: #5c9ded;
        transition: width .2s
    }

    .muted {
        color: #666;
        font-size: 12px
    }

    .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
        font-size: 11px;
        white-space: pre;
        max-height: 160px;
        overflow: auto;
        border: 1px solid #eee;
        padding: 8px;
        border-radius: 6px
    }

    .hidden {
        display: none
    }

    .btn {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 8px;
        cursor: pointer
    }
</style>

<div>
    <p class="muted" id="lastmsg">%LAST_MSG%</p>
    <p>Este proceso lee el <b>Records Catalog</b> vía su API interna y guarda un <code>.json</code> por cada record type
        en la carpeta seleccionada del File Cabinet.</p>
    <button id="startBtn" class="btn">Generar JSONs</button>
    <div id="status" class="muted" style="margin-top:10px"></div>
    <div class="bar" style="margin-top:8px">
        <div id="fill" class="fill"></div>
    </div>
    <div id="log" class="mono hidden" style="margin-top:10px"></div>
</div>

<script>
    (function () {
        const btn = document.getElementById('startBtn');
        const status = document.getElementById('status');
        const fill = document.getElementById('fill');
        const logEl = document.getElementById('log');
        const lastmsg = document.getElementById('lastmsg');

        function log(msg) {
            logEl.classList.remove('hidden');
            logEl.textContent += msg + "\\n";
        }

        async function xhrGet(url) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = () => (xhr.status === 200 ? resolve(xhr.responseText) : reject(new Error('HTTP ' + xhr.status)));
                xhr.onerror = () => reject(new Error('Network error'));
                xhr.send();
            });
        }

        async function postToSuitelet(bodyObj) {
            return fetch(window.location.href, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(bodyObj)
            }).then(r => {
                if (!r.ok) throw new Error('Save failed: ' + r.status);
                return r.json();
            });
        }

        function nowIsoLocal() {
            const d = new Date();
            const pad = n => ('0' + n).slice(-2);
            return d.getFullYear() + '-' + pad(d.getMonth() + 1) + '-' + pad(d.getDate()) +
                ' ' + pad(d.getHours()) + ':' + pad(d.getMinutes()) + ':' + pad(d.getSeconds());
        }

        async function run() {
            btn.disabled = true;
            status.textContent = 'Cargando lista de record types...';

            const rc = '/app/recordscatalog/rcendpoint.nl';
            const dataList = encodeURI(JSON.stringify({ structureType: 'FLAT' }));
            const listUrl = rc + '?action=getRecordTypes&data=' + dataList;

            const listResp = await xhrGet(listUrl);
            const recordTypes = JSON.parse(listResp);

            const items = (recordTypes && recordTypes.data) ? recordTypes.data : [];
            const total = items.length || 0;
            let done = 0;

            log('Record types: ' + total);

            for (const rt of items) {
                const scriptId = rt.id;
                status.textContent = 'Procesando: ' + scriptId + ' (' + (done + 1) + '/' + total + ')';

                // const dataDetail = encodeURI(JSON.stringify({ scriptId: scriptId, detailType: 'SS_ANAL' }));
                // El detailType exacto puede ajustarse; aquí lo dejamos como SS_ANAL como en tu ejemplo:
                const dataDetail = encodeURI(JSON.stringify({ scriptId: scriptId, detailType: 'SS_ANAL' }));
                const detUrl = rc + '?action=getRecordTypeDetail&data=' + dataDetail;

                try {
                    const detResp = await xhrGet(detUrl);
                    const detailObj = JSON.parse(detResp);

                    const savePayload = {
                        action: 'save',
                        name: scriptId + '.json',
                        json: JSON.stringify(detailObj.data, null, 2)
                    };
                    await postToSuitelet(savePayload);
                    log('✔ Guardado: ' + scriptId + '.json');
                } catch (e) {
                    log('✖ Error con ' + scriptId + ': ' + e.message);
                }

                done++;
                const pct = total ? Math.round((done / total) * 100) : 0;
                fill.style.width = pct + '%';
            }

            // Guardar/actualizar manifest.json
            try {
                await postToSuitelet({
                    action: 'saveManifest',
                    name: '${MANIFEST_NAME}',
                    json: JSON.stringify({ lastGenerated: nowIsoLocal() }, null, 2)
                });
                lastmsg.innerHTML = 'Último esquema generado: <b>' + nowIsoLocal() + '</b>';
                log('✔ Manifest actualizado: ${MANIFEST_NAME}');
            } catch (e) {
                log('✖ No se pudo actualizar manifest: ' + e.message);
            }

            status.textContent = 'Completado.';
            btn.disabled = false;
        }

        btn.addEventListener('click', run);
    })();
</script>